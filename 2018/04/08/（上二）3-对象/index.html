<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="你不知道的JS," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="对象的访问、描述符、冻结">
<meta name="keywords" content="你不知道的JS">
<meta property="og:type" content="article">
<meta property="og:title" content="（上二）3-对象">
<meta property="og:url" content="https://jjchu.github.io/2018/04/08/（上二）3-对象/index.html">
<meta property="og:site_name" content="Scoilar&#39;s Home">
<meta property="og:description" content="对象的访问、描述符、冻结">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://picture-market.oss-cn-beijing.aliyuncs.com/18-4-8/50990916.jpg">
<meta property="og:updated_time" content="2021-03-04T05:17:22.356Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="（上二）3-对象">
<meta name="twitter:description" content="对象的访问、描述符、冻结">
<meta name="twitter:image" content="http://picture-market.oss-cn-beijing.aliyuncs.com/18-4-8/50990916.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":20,"offset_float":0,"b2t":false,"scrollpercent":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jjchu.github.io/2018/04/08/（上二）3-对象/"/>





  <title> （上二）3-对象 | Scoilar's Home </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Scoilar's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">June</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://jjchu.github.io/2018/04/08/（上二）3-对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="June">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Scoilar's Home">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                （上二）3-对象
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-08T10:17:15+08:00">
                2018-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  对象的访问、描述符、冻结
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>对象可以通过两种形式定义:声明(文字)形式和构造形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">    key: value</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var myObj = new Object(); </span><br><span class="line">myObj.key = value;</span><br><span class="line"></span><br><span class="line">var myObj = Object.create(proto, [propertiesObject])</span><br></pre></td></tr></table></figure></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>JavaScript 中一共有六种主要类型：</p>
<ul>
<li><em>简单基本类型</em><ul>
<li>string </li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
</ul>
</li>
<li>object</li>
</ul>
<p>当然 es6 中新增了 Symbol 简单基本类型。</p>
<p><strong>注意</strong></p>
<ul>
<li>JavaScript 中万物皆是对象是不错误的。简单基本类型本身不是对象</li>
<li>typeof null 时会返回字符串 “object”，是一个 bug。<ul>
<li>原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”</li>
</ul>
</li>
</ul>
<p>JavaScript 中有许多特殊的对象子类型，我们可以称之为<em>复杂基本类型</em></p>
<ul>
<li>函数（可调用的对象）</li>
<li>数组</li>
<li>内置对象（String、Number、Boolean、Object、Function、Array、Date、RegExp、Error）</li>
</ul>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>我们知道，创建一个数据我们通常有两种方式实现：字面量形式和构造函数形式。但他们确实有不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var strPrimitive = &quot;I am a string&quot;;</span><br><span class="line">typeof strPrimitive;            // &quot;string&quot; </span><br><span class="line">strPrimitive instanceof String; // false</span><br><span class="line">strPrimitive.length             // 13</span><br><span class="line"></span><br><span class="line">var strObject = new String( &quot;I am a string&quot; );</span><br><span class="line">typeof strObject;               // &quot;object&quot;</span><br><span class="line">strObject instanceof String;    // true</span><br><span class="line">strObject.length                // 13</span><br></pre></td></tr></table></figure>
<p>如上，两种创建方式的 typeof 类型不同。字面量形式不是一个对象，但可以访问属性和使用方法。这是因为语言在必要的时候会隐式地将其转换为 String 对象。</p>
<blockquote>
<p>对象就是键 / 值对的集合。可以通过 <code>.propName</code> 或者 <code>[&quot;propName&quot;]</code> 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 <code>[[Get]]</code> 操作（在设置属性值时是 <code>[[Put]]</code>）， <code>[[Get]]</code> 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 <code>[[Prototype]]</code> 链（参见第 5 章）。<br>属性的特性可以通过属性描述符来控制，比如 <code>writable</code> 和 <code>configurable</code>。此外，可以使用 <code>Object.preventExtensions(..)</code>、<code>Object.seal(..)</code> 和 <code>Object.freeze(..)</code> 来设置对象(及其属性)的不可变性级别。<br>属性不一定包含值——它们可能是具备 <code>getter/setter</code> 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 <code>for..in</code> 循环中。<br>你可以使用 ES6 的 <code>for..of</code> 语法来遍历数据结构（数组、对象，等等）中的值，<code>for..of</code> 会寻找内置或者自定义的 <code>@@iterator</code> 对象并调用它的 <code>next()</code> 方法来遍历数据值。</p>
</blockquote>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>对象的内容是由一些存储在特定命名位置的(任意类型的)值组成的，我们称之为属性（对象就是键 / 值对的集合）</p>
<p>但这些值并非一定存储在对象内部。在引擎内部，这些值的存储方式是多种多样的，存储在对象容器内部的是这些属性的名称，它们就像指针(从技术角度 来说就是引用)一样，指向这些值真正的存储位置。</p>
<p><strong>对象的访问</strong></p>
<p>访问熟属性我们需要使用 <code>.</code> 操作符或者 <code>[]</code> 操作符。</p>
<ul>
<li><code>.a</code> 语法通 常被称为“属性访问”，<code>[&quot;a&quot;]</code> 语法通常被称为“键访问”。实际上它们访问的是同一个位置。</li>
<li>区别在于：<code>.</code>操作符要求属性名满足标识符的命名规范；<code>[&quot;..&quot;]</code> 语法可以接受任意 UTF-8/Unicode 字符串作为属性名，比如<code>&quot;Super- Fun!&quot;</code></li>
<li>而且如果你需要通过表达式来计算属性名，就得用 <code>myObject[..]</code> 这种属性访问语。比如<code>myObject[prefix + name]</code> 法就可以派上用场了</li>
<li>在对象中，属性名永远都是字符串。如果你使用其他值作为属性名，那它首先会被转换为一个字符串</li>
<li>每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别(除了可能发生的隐式绑定 this)</li>
</ul>
<p>ES6 增加了可计算属性名。可以在文字形式中使用 [] 包裹一个表达式来当作属性名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var prefix = &quot;foo&quot;;</span><br><span class="line">var myObject = &#123;</span><br><span class="line">    [prefix + &quot;bar&quot;]:&quot;hello&quot;,</span><br><span class="line">    [prefix + &quot;baz&quot;]: &quot;world&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>数组的访问</strong></p>
<p>数组有一套更加结构化的值存储机制，数组也支持 [] 访问形式，不过数组期望的是数值下标（通常被称为索引）</p>
<p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性，但不建议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myArray = [ &quot;foo&quot;, 42, &quot;bar&quot; ]; </span><br><span class="line">myArray.baz = &quot;baz&quot;;</span><br><span class="line">myArray.length;     // 3</span><br><span class="line">myArray.baz;        // &quot;baz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>复制对象</strong></p>
<ul>
<li><p>对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解 析出一个结构和值完全一样的对象）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newObj = JSON.parse( JSON.stringify( someObj ) );</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于浅复制，ES6 定义了 Object.assign(..) 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newObj = Object.assign( &#123;&#125;, myObject );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>属性描述符</strong></p>
<p>从 ES5 开始，所有的属性都具备了属性描述符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们也可以读取一个属性的描述信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );</span><br><span class="line">// &#123;</span><br><span class="line">// value: 2,</span><br><span class="line">// writable: true,</span><br><span class="line">// enumerable: true,</span><br><span class="line">// congurable: true </span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<p>obj.defineProperty()</p>
<ul>
<li>Writable —— 决定是否可以修改属性的值。严格模式下会报错</li>
<li>Configurable —— 属性是否可配置，即是否可以使用 defineProperty(..) 方法来修改属性描述符，不可以的话，普通模式和严格模式下都会报错</li>
<li>Enumerable —— 属性是否会出现在对象的属性枚举中（比如：for in）</li>
</ul>
<blockquote>
<p>注意：有一个小小的例外:即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true</p>
</blockquote>
<p><strong>对象的不变性</strong></p>
<p>在某些场景下，我们可能需要属性或者对象是不可改变的。在 ES5 中我们可以有好多方法实现。</p>
<blockquote>
<p>但这些方法都是浅不可变，它们只会影响目标对象和它的直接属性；如果目标对象引用了其他对象，则其他对象的内容仍是可变的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Object.defineProperty(...)</code></td>
<td>创建一个真正的常量属性(不可修改、 重定义或者删除)</td>
<td>示例1</td>
</tr>
<tr>
<td><code>Object.preventExtensions(..)</code></td>
<td>禁止一个对象添加新属性并且保留已有属性</td>
<td>示例2</td>
</tr>
<tr>
<td><code>Object.seal(..)</code></td>
<td>创建一个“密封”的对象，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以 修改属性的值)</td>
<td>示例3</td>
</tr>
<tr>
<td><code>Object.seal(..)</code></td>
<td>创建一个冻结对象，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性，也不能修改属性的值</td>
<td>示例4</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 实例1    创建常量（不可修改、 重定义或者删除）</span><br><span class="line">Object.defineProperty( myObject, &quot;FAVORITE_NUMBER&quot;, &#123;</span><br><span class="line">    value: 42,</span><br><span class="line">    writable: false,</span><br><span class="line">    configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 实例2    禁止扩展（禁止一个对象添加新属性）</span><br><span class="line">Object.preventExtensions( myObject )</span><br><span class="line"></span><br><span class="line">// 示例3    密封对象（不能添加新属性，不能重新配置或者删除任何现有属性，但可以修改）</span><br><span class="line">Object.seal( myObject )</span><br><span class="line"></span><br><span class="line">// 示例4    冻结对象（级别最高，禁止对于对象本身及其任意 直接属性的修改）</span><br><span class="line">Object.freeze( myObject )</span><br></pre></td></tr></table></figure>
<p>一个深度冻结对象的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(obj) &#123;</span><br><span class="line">  // 取回定义在obj上的属性名</span><br><span class="line">  var propNames = Object.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  // 在冻结自身之前冻结属性</span><br><span class="line">  propNames.forEach(function(name) &#123;</span><br><span class="line">    var prop = obj[name];</span><br><span class="line"></span><br><span class="line">    // 如果prop是个对象，冻结它</span><br><span class="line">    if (typeof prop == &apos;object&apos; &amp;&amp; prop !== null)</span><br><span class="line">      deepFreeze(prop);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 冻结自身(no-op if already frozen)</span><br><span class="line">  return Object.freeze(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>[[Get]]</strong></p>
<p>属性访问在实现时有一个微妙却非常重要的细节，（在语言规范中）实际上是实现了 <code>[[Get]]</code> 操作（有点像函数调用:<code>[[Get]]()</code>）:</p>
<ul>
<li>首先，对象默认的内置 <code>[[Get]]</code> 操作首先在对象中查找是否有名称相同的属性；</li>
<li>第二步，遍历可能存在的 <code>[[Prototype]]</code> 链，也就是原型链；</li>
<li>无论如何都没有找到名称相同的属性，那 <code>[[Get]]</code> 操作会返回值 <code>undefined</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123; </span><br><span class="line">    a: 2</span><br><span class="line">&#125;;</span><br><span class="line">myObject.a; // 2</span><br></pre></td></tr></table></figure>
<p>如果访问一个不存在的属性，虽然返回 <code>undefined</code>，实际上底层的 <code>[[Get]]</code> 操作进行了更复杂的处理</p>
<p><strong>[[Put]]</strong></p>
<p><code>[[Put]]</code> 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）</p>
<p>如果对象中已经存在这个属性，<code>[[Put]]</code> 算法大致会检查下面这些内容:</p>
<ul>
<li>属性是否是访问描述符？如果是并且存在<code>setter</code>就调用<code>setter</code></li>
<li>属性的数据描述符中<code>writable</code>是否是<code>false</code>？如果是，在非严格模式下静默失败，在严格模式下抛出 <code>TypeError</code> 异常</li>
<li>如果都不是，将该值设置为属性的值。</li>
</ul>
<p>如果对象中不存在这个属性，<code>[[Put]]</code> 操作会更加复杂</p>
<p><strong>访问描述符（Getter和Setter）</strong></p>
<p>对象默认的 <code>[[Put]]</code> 和 <code>[[Get]]</code> 操作分别可以控制属性值的设置和获取；但在 ES5 中可以使用 <code>getter</code> 和 <code>setter</code> 部分改写默认操作。</p>
<p>当你给一个属性定义 <code>getter</code>、<code>setter</code> 或者两者都有时，这个属性会被定义为“访问描述符”：</p>
<ul>
<li>只能应用在单个属性上，无法应用在整个对象上</li>
<li><code>getter</code> 是一个隐藏函数，会在获取属性值时调用</li>
<li><code>setter</code> 也是一个隐藏函数，会在设置属性值时调用</li>
<li>对于访问描述符来说，<code>JavaScript</code> 会忽略它们的 <code>value</code> 和 <code>writable</code> 特性，取而代之的是关心 <code>set</code> 和 <code>get</code>（还有 <code>configurable</code> 和 <code>enumerable</code>）特性</li>
</ul>
<p>定义访问描述符有两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 对象语法</span><br><span class="line">var myObject = &#123;</span><br><span class="line">    // 给 a 定义一个 getter </span><br><span class="line">    get a() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// defineProperty 显示定义</span><br><span class="line">Object.defineProperty(myObject, &quot;b&quot;, &#123;</span><br><span class="line">    // 描述符</span><br><span class="line">    // 给 b 设置一个 getter</span><br><span class="line">    get: function()&#123; return this.a * 2 &#125;,</span><br><span class="line">    // 确保 b 会出现在对象的属性列表中</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>getter</code> 会在对象中创建一个不包含值的属性，对这个属性的访问会自动调用一个隐藏函数，<code>get</code> 的返回值会被当作属性访问的返回值；此时即对此属性重新赋值，也将无意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    get a() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = 3; // 赋值无意义</span><br><span class="line">myObject.a;     // 2</span><br></pre></td></tr></table></figure>
<p><code>setter</code> 会覆盖单个属性默认的<code>[[Put]]</code> （也被称为赋值）操作；通常来说 <code>getter</code> 和 <code>setter</code> 是成对出现的（只定义一个的话通常会产生意料之外的行为）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    get a() &#123;</span><br><span class="line">        return this._a_;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    set a(val) &#123;</span><br><span class="line">        this._a_ = val * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = 2;</span><br><span class="line">myObject.a; // 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本例中，实际上我们把赋值（ <code>[[Put]]</code> ）操作中的值 2 存储到了另一个变量<br><code>_a_</code> 中。名称 <code>_a_</code> 只是一种惯例，没有任何特殊的行为——和其他普通属性<br>一样</p>
</blockquote>
<p><strong>存在性</strong></p>
<p> 因为 myObject.a 的属性访问返回值可能是 <code>undefined</code> ，但是这个值有可能是属性中存储的 <code>undefined</code> ，也可能是因为属性不存在所以返回 <code>undefined</code>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a: undefined</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a  // undefined</span><br><span class="line">myObject.b  // undefined</span><br></pre></td></tr></table></figure>
<p>如何区别？</p>
<ul>
<li>in 操作符会检查属性是否在对象及其 <code>[[Prototype]]</code> 原型链中；</li>
<li><code>hasOwnProperty(..)</code> 只会检查属性是否在 <code>myObject</code> 对象中，不会检查 <code>[[Prototype]]</code> 链<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a:2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 方式 1 </span><br><span class="line">(&quot;a&quot; in myObject); // true</span><br><span class="line">(&quot;b&quot; in myObject); // false</span><br><span class="line"></span><br><span class="line">// 方式 2</span><br><span class="line">myObject.hasOwnProperty( &quot;a&quot; ); // true</span><br><span class="line">myObject.hasOwnProperty( &quot;b&quot; ); // false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注：最好使用 <code>Object.prototype.hasOwnProperty.
call(myObject,&quot;a&quot;)</code>；防止通过 <code>Object.create(null)</code> 来创建对象时原型链中断。</p>
</blockquote>
<p><strong>枚举</strong></p>
<p>对象的可枚举，意即“可以出现在对象属性的遍历中”。主要是 for…in 循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(myObject,&quot;a&quot;,&#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    value: 2</span><br><span class="line">&#125;);</span><br><span class="line">// 可以访问</span><br><span class="line">myObject.a;         // 2        可以访问</span><br><span class="line">(a in myObject);    // true     存在</span><br><span class="line"></span><br><span class="line">for (var k in myObject) &#123;   // 但不能便利</span><br><span class="line">    console.log( k, myObject[k] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不<br>仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用<br>for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引</p>
</blockquote>
<p>我们还可以通过一些方式来直接区分属性是否可枚举：</p>
<ul>
<li><code>propertyIsEnumerable(..)</code>表示指定的属性名是否可枚举的Boolean；但是通过原型链继承的属性除外</li>
<li><code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性;但<code>Object.getOwnPropertyNames(..)</code><br>会返回一个数组，包含所有属性，无论它们是否可枚举<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myObject.propertyIsEnumerable( &quot;a&quot; );   // false</span><br><span class="line">Object.keys( myObject );                // []</span><br><span class="line">Object.getOwnPropertyNames( myObject ); // [&quot;a&quot;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>对象的遍历：</p>
<ul>
<li>我们一般用 <code>for..in</code> 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)<ul>
<li><code>for..in</code> 遍历的是对象中的所有可枚举属性（key），所以需要我们手动获取值（value）</li>
<li>遍历的顺序是不确定的</li>
</ul>
</li>
<li>ES6 中我们可以通过 <code>for...of</code> 来遍历一个<strong>定义了迭代器的对象</strong>的值（value）</li>
</ul>
<p>数组的遍历：</p>
<ul>
<li>我们可以用 <code>for..in</code> 循环来遍历数组，但拿到的是数组的下标，相当于 key 值；但不推荐，不仅会包含所有数值索引，还会包含所有可枚举属性</li>
<li>我们可以正常使用 for 循坏来遍历一个数组；</li>
<li>ES5 中增加了一些数组的辅助迭代器，包括 forEach(..)、every(..) 和 some(..)。every(..) 和 some(..) 会提前终止遍历</li>
<li>ES6 中增加了一种用来遍历数组的 <code>for..of</code> 循环语法（因为数组内置迭代器）<ul>
<li><code>for..of</code> 不会遍历手动添加到数组上的属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arr = [3, 5, 7];</span><br><span class="line">arr.foo = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (let i in arr) &#123;</span><br><span class="line">  console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i of arr) &#123;</span><br><span class="line">  console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="1-有哪些方法可以创建一个对象？"><a href="#1-有哪些方法可以创建一个对象？" class="headerlink" title="1. 有哪些方法可以创建一个对象？"></a>1. 有哪些方法可以创建一个对象？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 字面量形式</span><br><span class="line">var myObj = &#123;</span><br><span class="line">    key: value</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line">// 2. 构造函数形式</span><br><span class="line">var myObj = new Object(); </span><br><span class="line">myObj.key = value;</span><br><span class="line">// 3. API 形式</span><br><span class="line">var myObj = Object.create(proto, [propertiesObject])</span><br></pre></td></tr></table></figure>
<p>字面形式更常用，不过有时候构造形式可以提供更多选项。</p>
<h4 id="2-JS-中的数据类型？"><a href="#2-JS-中的数据类型？" class="headerlink" title="2. JS 中的数据类型？"></a>2. JS 中的数据类型？</h4><p><img src="http://picture-market.oss-cn-beijing.aliyuncs.com/18-4-8/50990916.jpg" alt=""></p>
<p>所以，<strong><code>JavaScript</code> 中万物皆是对象这句话显然是错误的</strong>。</p>
<h4 id="3-为什么typeof-null返回的是object？"><a href="#3-为什么typeof-null返回的是object？" class="headerlink" title="3. 为什么typeof null返回的是object？"></a>3. 为什么<code>typeof null</code>返回的是<code>object</code>？</h4><p>注意，简单基本类型（<code>string</code>、<code>boolean</code>、<code>number</code>、<code>null</code> 和 <code>undefined</code>）本身并不是对象。 <code>null</code> 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 <code>null</code> 执行 <code>typeof null</code> 时会返回字符串 <code>&quot;object&quot;</code>。实际上，<code>null</code> 本身是基本类型，原理是这样的，不同的对象在底层都表示为二进制，在 <code>JavaScript</code> 中二进制前三位都为 0 的话会被判断为 <code>object</code> 类型，<code>null</code> 的二进制表示是全 0，自然前三位也是 0，所以执行 <code>typeof</code> 时会返回<code>“object”</code></p>
<h4 id="4-基本数据类型字面量形式不是对象，为什么可以使用方法？"><a href="#4-基本数据类型字面量形式不是对象，为什么可以使用方法？" class="headerlink" title="4. 基本数据类型字面量形式不是对象，为什么可以使用方法？"></a>4. 基本数据类型字面量形式不是对象，为什么可以使用方法？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var strPrimitive = &quot;I am a string&quot;;</span><br><span class="line">typeof strPrimitive;            // &quot;string&quot;</span><br><span class="line">strPrimitive instanceof String; // false</span><br><span class="line"></span><br><span class="line">var strObject = new String( &quot;I am a string&quot; );</span><br><span class="line">typeof strObject;               // &quot;object&quot;</span><br><span class="line">strObject instanceof String;    // true</span><br><span class="line">// 检查 sub-type 对象</span><br><span class="line">Object.prototype.toString.call( strObject ); // [object String]</span><br></pre></td></tr></table></figure>
<p>原始值 <code>&quot;I am a string&quot;</code> 并不是一个对象，它只是一个字面量，并且是一个不可变的值。 如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其转换为 <code>String</code> 对象。在 <code>JavaScript</code> 中必要时语言会自动把字符串字面量转换成一个 <code>String</code> 对象，也就是说你并不需要显式创建一个对象。<code>JavaScript</code> 社区中的大多数人都认为能使用文字形式时就不要使用构造形式。</p>
<h4 id="5-JS-中的对象？"><a href="#5-JS-中的对象？" class="headerlink" title="5. JS 中的对象？"></a>5. JS 中的对象？</h4><p>对象就是键 / 值对的集合。可以通过 <code>.propName</code> 或者 <code>[&quot;propName&quot;]</code> 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 <code>[[Get]]</code> 操作（在设置属性值时是 <code>[[Put]]</code>）， <code>[[Get]]</code> 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 <code>[[Prototype]]</code> 链。<br>属性的特性可以通过属性描述符来控制，比如 <code>writable</code> 和 <code>configurable</code>。此外，可以使用 <code>Object.preventExtensions(..)</code>、<code>Object.seal(..)</code> 和 <code>Object.freeze(..)</code> 来设置对象（及其属性）的不可变性级别。<br>属性不一定包含值——它们可能是具备 <code>getter/setter</code> 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 <code>for..in</code> 循环中。<br>你可以使用 ES6 的 <code>for..of</code> 语法来遍历数据结构（数组、对象，等等）中的值，<code>for..of</code> 会寻找内置或者自定义的 <code>@@iterator</code> 对象并调用它的 <code>next()</code> 方法来遍历数据值。</p>
<h4 id="6-对象的拷贝？"><a href="#6-对象的拷贝？" class="headerlink" title="6. 对象的拷贝？"></a>6. 对象的拷贝？</h4><ul>
<li><p>对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newObj = JSON.parse( JSON.stringify( someObj ) );</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于浅复制，ES6 定义了 <code>Object.assign(..)</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newObj = Object.assign( &#123;&#125;, myObject );</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝一个对象，我们可以自我封装</p>
</li>
</ul>
<h4 id="7-对象的属性描述符？"><a href="#7-对象的属性描述符？" class="headerlink" title="7. 对象的属性描述符？"></a>7. 对象的属性描述符？</h4><p>从 ES5 开始，所有的属性都具备了属性描述符。对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符</strong>和<strong>存取描述符</strong></p>
<p>数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一，不能同时是两者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 1. 数据描述符</span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">    value: 2,</span><br><span class="line">    writable: true,         // 决定是否可以修改属性的值。严格模式下会报错</span><br><span class="line">    configurable: true,     // 属性是否可配置，即是否可以使用 defineProperty(..)</span><br><span class="line">    enumerable: true        // 属性是否会出现在对象的属性枚举中（比如：for in）</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2. 存取描述符</span><br><span class="line">Object.defineProperty( myObject, &quot;a&quot;, &#123;</span><br><span class="line">    get() &#123; return _a_ &#125;,</span><br><span class="line">    set(newVal) &#123; _a_ = newVal &#125;,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：有一个小小的例外:即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true</p>
</blockquote>
<h4 id="8-怎么冻结一个对象？"><a href="#8-怎么冻结一个对象？" class="headerlink" title="8. 怎么冻结一个对象？"></a>8. 怎么冻结一个对象？</h4><p>在某些场景下，我们可能需要属性或者对象是不可改变的。在 ES5 中我们可以有好多方法实现。</p>
<blockquote>
<p>但这些方法都是浅不可变，它们只会影响目标对象和它的直接属性；如果目标对象引用了其他对象，则其他对象的内容仍是可变的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Object.defineProperty(...)</code></td>
<td>创建一个真正的常量属性(不可修改、 重定义或者删除) </td>
</tr>
<tr>
<td><code>Object.preventExtensions(..)</code></td>
<td>禁止一个对象添加新属性并且保留已有属性 </td>
</tr>
<tr>
<td><code>Object.seal(..)</code></td>
<td>创建一个“密封”的对象，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值) </td>
</tr>
<tr>
<td><code>Object.seal(..)</code></td>
<td>创建一个冻结对象，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性，也不能修改属性的值 </td>
</tr>
</tbody>
</table>
<p>一个深度冻结对象的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(obj) &#123;</span><br><span class="line">  // 取回定义在obj上的属性名</span><br><span class="line">  var propNames = Object.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">  // 在冻结自身之前冻结属性</span><br><span class="line">  propNames.forEach(function(name) &#123;</span><br><span class="line">    var prop = obj[name];</span><br><span class="line"></span><br><span class="line">    // 如果prop是个对象，冻结它</span><br><span class="line">    if (typeof prop == &apos;object&apos; &amp;&amp; prop !== null)</span><br><span class="line">      deepFreeze(prop);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 冻结自身(no-op if already frozen)</span><br><span class="line">  return Object.freeze(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/你不知道的JS/" rel="tag"># 你不知道的JS</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/04/（上二）2-this详解/" rel="next" title="（上二）2-this详解">
                <i class="fa fa-chevron-left"></i> （上二）2-this详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/11/（上二）4-混合对象”类“/" rel="prev" title="（上二）4-混合对象“类”">
                （上二）4-混合对象“类” <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="June" />
          <p class="site-author-name" itemprop="name">June</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JJChu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://ws1.sinaimg.cn/large/b6d81e13ly1fow7dwvspij20e80e8q2v.jpg" target="_blank" title="WeChat">
                  
                    <i class="fa fa-fw fa-weixin"></i>
                  
                  WeChat
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/3067616787/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法"><span class="nav-number">1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">2.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内置函数"><span class="nav-number">2.1.</span> <span class="nav-text">内置函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内容"><span class="nav-number">3.</span> <span class="nav-text">内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历"><span class="nav-number">4.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-有哪些方法可以创建一个对象？"><span class="nav-number">5.1.</span> <span class="nav-text">1. 有哪些方法可以创建一个对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-JS-中的数据类型？"><span class="nav-number">5.2.</span> <span class="nav-text">2. JS 中的数据类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-为什么typeof-null返回的是object？"><span class="nav-number">5.3.</span> <span class="nav-text">3. 为什么typeof null返回的是object？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-基本数据类型字面量形式不是对象，为什么可以使用方法？"><span class="nav-number">5.4.</span> <span class="nav-text">4. 基本数据类型字面量形式不是对象，为什么可以使用方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-JS-中的对象？"><span class="nav-number">5.5.</span> <span class="nav-text">5. JS 中的对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-对象的拷贝？"><span class="nav-number">5.6.</span> <span class="nav-text">6. 对象的拷贝？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-对象的属性描述符？"><span class="nav-number">5.7.</span> <span class="nav-text">7. 对象的属性描述符？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-怎么冻结一个对象？"><span class="nav-number">5.8.</span> <span class="nav-text">8. 怎么冻结一个对象？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">June</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
